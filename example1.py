# В переменных x и y находятся числовые значения.
# Сделать так, чтобы в x оказалось большее из двух чисел, а в y - меньшее.
# if x < y:
#     x, y = y, x

# Задан год в переменной year. Определить, к какому веку он относится, например, 2014 год относится к 21 веку. Век записать в  переменную c. ВАЖНО: все строки программы начинайте с одного пробела!
#  Заданный год уже записан в переменную year, не изменяйте ее значение
# c = 0
# if year % 100 > 0:
#     c = year // 100 + 1
# else:
#     c = year // 100
# print(c)

# Даны три числа: a,b и c.
# Определить, можно ли их выстроить так, чтобы получилась арифметическая прогрессия.
# Если это возможно, переменная progress должна получить значение True, в противном случае - False.
# ВАЖНО: все строки программы начинайте с одного пробела!
#
# tmp = [a, b, c]
# tmp.sort(reverse=True)
# if tmp[0] == tmp[1] + tmp[2]:
#     progress = True
# else:
#     progress = False

# Год является високосным в двух случаях:
# 1) либо он кратен 4, но при этом не кратен 100,
# 2) либо кратен 400.
# В переменной year – год, Присвойте переменной leap выражение, которое равно True,
# если год високосный и False в противном случае.
# ВАЖНО: все строки программы начинайте с одного пробела!
#
# if year % 4 != 0 or (year % 100 == 0 and year % 400 != 0):
#     leap = False
# else:
#     leap = True

# Переменная n содержит целое положительное нечетное число.
# Подсчитать произведение чисел 1*3*5*...*n и сохранить его в переменной prod.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная n содержит целое положительное нечетное число.
# prod = 1
# for i in range(1, n + 1, 2):
#     prod *= i

# Переменная n содержит целое неотрицательное число.
# Подсчитать сумму степеней двойки от нулевой до n-й включительно. Сумму сохранить в переменной sum.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная n содержит число.
# i = 0
# sum = 0
# base = 2
# while i <= n:
#     sum = sum + base ** i
#     i += 1
#
# Сумма всех делителей числа 12 равна 12 + 6 + 4 + 3 + 2 + 1 = 28.
# Подсчитать и сохранить в переменной d сумму всех делителей целого числа m (m > 0).
# Переменная m уже имеет значение.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная m содержит целое положительное число.
# d = 0
# i = 1
# while i <= m:
#     if m % i == 0:
#         d = d + i
#     i += 1
#
# Объявить функцию avg() для поиска среднего арифметического двух чисел
#
# def avg(a, b):
#     return (a + b) // 2
#
# Определить функцию max3(a,b,c) для поиска максимального из трех чисел.
# Не использовать функцию max.
#
# def max3(a, b, c):
#     if a > b:
#         if a > c:
#             return a
#         else:
#             return c
#     else:
#         if b > c:
#             return b
#         else:
#             return c
#
# Объявить функцию avg() для поиска среднего арифметического от двух до пяти чисел.
# Например, avg(1, 2, 3) = 2, avg(3, 2, 0, 1) = 1.5.
#
# DEFAULT1 = object()
# DEFAULT2 = object()
# DEFAULT3 = object()
# def avg(a, b, c=DEFAULT1, d=DEFAULT2, e=DEFAULT3):
#     countOfDefinedParams = 2
#     if c is DEFAULT1:
#         c = 0
#     else:
#         countOfDefinedParams += 1
#     if d is DEFAULT2:
#         d = 0
#     else:
#         countOfDefinedParams += 1
#     if e is DEFAULT3:
#         e = 0
#     else:
#         countOfDefinedParams += 1
#     return (a + b + c + d + e) / countOfDefinedParams
#
# Объявить функцию sign(z), которая
# вернет -1, если z отрицательно,
# вернет 1, если z положительно и
# вернет 0, если z равно нулю.
#
# def sign(z):
#     if(z< 0):
#         return -1
#     elif(z==0):
#         return 0
#     else:
#         return 1
#
# Задано целое число n. Найти сумму 1 + 2 + 3 + … + n.
# Для этого объявите функцию progrSum(n), которая получает число n и возвращает требуемую сумму.
#
# def progrSum(n):
#     summa = 0
#     i = 1
#     while i <= n:
#         summa = summa + i
#         i += 1
#     return summa
#
# Задано целое число n.
# Найти знакопеременную сумму 1 – 2 + 3 – 4 + 5 – 6 +… - n.
# Для этого объявите функцию xsum(n).
#
# def xsum(n):
#     symbol = 1
#     res = 0
#     for i in range(1, n + 1):
#         res = res + i * symbol
#         symbol = symbol * (-1)
#     return res
#
# Задано целое число n. Найти произведение 1 * 2 * 3 * … * n.
# Для этого объявите функцию factorial(n), которая получает число n и возвращает n!.
# Учтите, что 0! = 1.
#
# def factorial(n):
#     if n == 0:
#         return 1
#     else:
#         return n * factorial(n-1)
#
# Задано целое число n. Объявите функцию sum_fact(n),
# которая найдет сумму факториалов от 1! до n!.
#
# def sum_fact(n):
#     j = 1
#     sum = 0
#     for i in range(1, n + 1):
#         j *= i
#         sum += j
#     return sum

# Дано целое число.  Составить список из всех натуральных чисел, меньших, чем заданное.
# Для этого объявите функцию natList, которая получает число и возвращает список.
#
# def natList(n):
#     a = []
#     for x in range(1, n):
#         a.append(x)
#     return a
#
# Объявить функцию product(n), которая получает список и возвращает произведение его элементов.
#
# def product(n):
#     summa = 1
#     for i in n:
#         summa *= i
#     return summa
#
# Определите функцию isInList(e, lst), которая получает элемент e и список lst
# и проверяет, встречается ли данный элемент в данном списке.
# Если элемент встречается хотя бы раз, функция возвращает True,
# если не встречается ни разу, функция возвращает False.
#
# def isInList(e, lst):
#     if e in lst:
#         return True
#     else:
#         return False
#
# Определите функцию count(e, lst), которая получает элемент e и список lst и считает,
# сколько раз данный элемент встречается в данном списке.
# Функция возвращает число вхождений. Если элемент не встречается ни разу, функция возвращает 0.
#
# def count(e, lst):
#     if e in lst:
#         return lst.count(e)
#     else:
#         return 0
#
# Дан числовой список s. Создать из него новый список путем замены всех вхождений элемента a на элемент b.
# Для этого определите функцию replace(s, a, b), которая возвращает новый список.
#
# def replace(oldList, a, b):
#     newList = list(oldList)
#     for i in range(0, len(oldList)):
#         print(i)
#         if oldList[i] == a:
#             newList[i] = b
#     return newList
#
# Дан числовой список s. Заменить в нем все вхождения элемента a на элемент b.
# Для этого определите функцию replace(s, a, b), которая изменяет список s.
#
# def replace(s, a, b):
#     list(s)
#     for i in range(0, len(s)):
#         if s[i] == a:
#             s[i] = b
#     return s
#
# Объявить функцию  exclude(), которая получает два списка и удаляет из первого списка все элементы,
# которые встречаются во втором списке.
# [a,b,c,d], [b,d,e,f] => [a,c].
#
# def exclude(lst1, lst2):
#     for i in lst2:
#         if i  in lst1:
#             lst1.remove(i)
#     return lst1
#
# Объявить функцию myzip(), которая получает два списка равной длины и возвращает список пар.
# Каждая пара является двухэлементным списком, первый элемент пары берется из первого списка,
# второй – из второго. [1,2,3], ['a', 'b', 'c'] => [[1,'a'], [2,'b'], [3,'c']].
#
# def myzip(list0, list1):
#     res = []
#     for i in range(len(list0)):
#         res.append([list0[i], list1[i]])
#     return res

# Задан числовой список. Оставить в нем только положительные числа. Для этого объявить функцию positive(lst), которая ничего не возвращает, но изменяет список lst.
#
# def positive(lst):
#     for item in list(lst):
#         if item <= 0:
#             lst.remove(item)
#
# Задан числовой список. Переставить в нем числа так, чтобы вначале шли все отрицательные числа, а за ними все положительные.
# Для этого объявите функцию order, которая изменяет исходный список и нового списка не создает.
#
# def order(l):
#     l.sort()
#
# Дан двухуровневый список списков из целых чисел.
# Сделать из него новый одноуровневый список, в котором числа следуют в том же порядке.
# Например, [[1,2,3],[4,5],[1,2]]->[1,2,3,4,5,1,2].
# Определите функцию flatten(lst), которая получает двухуровневый список
# и возвращает одноуровневый.
#
# def flatten(lst):
#     res = []
#     for i in lst:
#         for j in i:
#             res.append(j)
#     return res
#
# Задан список, упорядоченный по возрастанию.
# Вставить в него новый элемент так, чтобы порядок не нарушился.
# Для этого объявите функцию ordInsert(lst,e), которая изменяет исходный список
# и нового списка не создает. Не использовать метод sort.
#
# def ordInsert(lst, e):
#     for index in range(0, len(lst)):
#         if e < lst[index] and e > lst[index - 1]:
#             lst.insert(index, e)
#             break
#         elif e < lst[0]:
#             lst.insert(0, e)
#             break
#         elif e > lst[len(lst) - 1]:
#             lst.append(e)
#             break
#
# Задан список из числовых списков. Отсортировать его по возрастанию сумм чисел во вложенных списках.
# Для этого объявите функцию sortBySum(lst), которая сортирует исходный список.
#
# def sortBySum(lst):
#     lst.sort(key=sum)
#
# Задан список. Оставить в нем только уникальные элементы, например, [1,3,2,4,3,2,1] => [1,3,2,4].
# Для этого объявите функцию distinct, которая получает исходный список
# и возвращает новый список, в котором нет повторяющихся элементов.
#
# def distinct(list1):
#     newlist = []
#     for x in list1:
#         if x not in newlist:
#             newlist.append(x)
#     return newlist

