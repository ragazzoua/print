# В переменных x и y находятся числовые значения.
# Сделать так, чтобы в x оказалось большее из двух чисел, а в y - меньшее.
# if x < y:
#     x, y = y, x

# Задан год в переменной year. Определить, к какому веку он относится, например, 2014 год относится к 21 веку. Век записать в  переменную c. ВАЖНО: все строки программы начинайте с одного пробела!
#  Заданный год уже записан в переменную year, не изменяйте ее значение
# c = 0
# if year % 100 > 0:
#     c = year // 100 + 1
# else:
#     c = year // 100
# print(c)

# Даны три числа: a,b и c.
# Определить, можно ли их выстроить так, чтобы получилась арифметическая прогрессия.
# Если это возможно, переменная progress должна получить значение True, в противном случае - False.
# ВАЖНО: все строки программы начинайте с одного пробела!
#
# tmp = [a, b, c]
# tmp.sort(reverse=True)
# if tmp[0] == tmp[1] + tmp[2]:
#     progress = True
# else:
#     progress = False

# Год является високосным в двух случаях:
# 1) либо он кратен 4, но при этом не кратен 100,
# 2) либо кратен 400.
# В переменной year – год, Присвойте переменной leap выражение, которое равно True,
# если год високосный и False в противном случае.
# ВАЖНО: все строки программы начинайте с одного пробела!
#
# if year % 4 != 0 or (year % 100 == 0 and year % 400 != 0):
#     leap = False
# else:
#     leap = True

# Переменная n содержит целое положительное нечетное число.
# Подсчитать произведение чисел 1*3*5*...*n и сохранить его в переменной prod.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная n содержит целое положительное нечетное число.
# prod = 1
# for i in range(1, n + 1, 2):
#     prod *= i

# Переменная n содержит целое неотрицательное число.
# Подсчитать сумму степеней двойки от нулевой до n-й включительно. Сумму сохранить в переменной sum.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная n содержит число.
# i = 0
# sum = 0
# base = 2
# while i <= n:
#     sum = sum + base ** i
#     i += 1
#
# Сумма всех делителей числа 12 равна 12 + 6 + 4 + 3 + 2 + 1 = 28.
# Подсчитать и сохранить в переменной d сумму всех делителей целого числа m (m > 0).
# Переменная m уже имеет значение.
# Важно! Код решения должен быть записан с отступом, как минимум, в один пробел.
#
# # переменная m содержит целое положительное число.
# d = 0
# i = 1
# while i <= m:
#     if m % i == 0:
#         d = d + i
#     i += 1
#
# Объявить функцию avg() для поиска среднего арифметического двух чисел
#
# def avg(a, b):
#     return (a + b) // 2
#
# Определить функцию max3(a,b,c) для поиска максимального из трех чисел.
# Не использовать функцию max.
#
# def max3(a, b, c):
#     if a > b:
#         if a > c:
#             return a
#         else:
#             return c
#     else:
#         if b > c:
#             return b
#         else:
#             return c
#
# Объявить функцию avg() для поиска среднего арифметического от двух до пяти чисел.
# Например, avg(1, 2, 3) = 2, avg(3, 2, 0, 1) = 1.5.
#
# DEFAULT1 = object()
# DEFAULT2 = object()
# DEFAULT3 = object()
# def avg(a, b, c=DEFAULT1, d=DEFAULT2, e=DEFAULT3):
#     countOfDefinedParams = 2
#     if c is DEFAULT1:
#         c = 0
#     else:
#         countOfDefinedParams += 1
#     if d is DEFAULT2:
#         d = 0
#     else:
#         countOfDefinedParams += 1
#     if e is DEFAULT3:
#         e = 0
#     else:
#         countOfDefinedParams += 1
#     return (a + b + c + d + e) / countOfDefinedParams
#
# Объявить функцию sign(z), которая
# вернет -1, если z отрицательно,
# вернет 1, если z положительно и
# вернет 0, если z равно нулю.
#
# def sign(z):
#     if(z< 0):
#         return -1
#     elif(z==0):
#         return 0
#     else:
#         return 1
#
# Задано целое число n. Найти сумму 1 + 2 + 3 + … + n.
# Для этого объявите функцию progrSum(n), которая получает число n и возвращает требуемую сумму.
#
# def progrSum(n):
#     summa = 0
#     i = 1
#     while i <= n:
#         summa = summa + i
#         i += 1
#     return summa
#
# Задано целое число n.
# Найти знакопеременную сумму 1 – 2 + 3 – 4 + 5 – 6 +… - n.
# Для этого объявите функцию xsum(n).
#
# def xsum(n):
#     symbol = 1
#     res = 0
#     for i in range(1, n + 1):
#         res = res + i * symbol
#         symbol = symbol * (-1)
#     return res
#
# Задано целое число n. Найти произведение 1 * 2 * 3 * … * n.
# Для этого объявите функцию factorial(n), которая получает число n и возвращает n!.
# Учтите, что 0! = 1.
#
# def factorial(n):
#     if n == 0:
#         return 1
#     else:
#         return n * factorial(n-1)
#
# Задано целое число n. Объявите функцию sum_fact(n),
# которая найдет сумму факториалов от 1! до n!.
#
# def sum_fact(n):
#     j = 1
#     sum = 0
#     for i in range(1, n + 1):
#         j *= i
#         sum += j
#     return sum

# Дано целое число.  Составить список из всех натуральных чисел, меньших, чем заданное.
# Для этого объявите функцию natList, которая получает число и возвращает список.
#
# def natList(n):
#     a = []
#     for x in range(1, n):
#         a.append(x)
#     return a
#
# Объявить функцию product(n), которая получает список и возвращает произведение его элементов.
#
# def product(n):
#     summa = 1
#     for i in n:
#         summa *= i
#     return summa
#
# Определите функцию isInList(e, lst), которая получает элемент e и список lst
# и проверяет, встречается ли данный элемент в данном списке.
# Если элемент встречается хотя бы раз, функция возвращает True,
# если не встречается ни разу, функция возвращает False.
#
# def isInList(e, lst):
#     if e in lst:
#         return True
#     else:
#         return False
#
# Определите функцию count(e, lst), которая получает элемент e и список lst и считает,
# сколько раз данный элемент встречается в данном списке.
# Функция возвращает число вхождений. Если элемент не встречается ни разу, функция возвращает 0.
#
# def count(e, lst):
#     if e in lst:
#         return lst.count(e)
#     else:
#         return 0
#
# Дан числовой список s. Создать из него новый список путем замены всех вхождений элемента a на элемент b.
# Для этого определите функцию replace(s, a, b), которая возвращает новый список.
#
# def replace(oldList, a, b):
#     newList = list(oldList)
#     for i in range(0, len(oldList)):
#         print(i)
#         if oldList[i] == a:
#             newList[i] = b
#     return newList
#
# Дан числовой список s. Заменить в нем все вхождения элемента a на элемент b.
# Для этого определите функцию replace(s, a, b), которая изменяет список s.
#
# def replace(s, a, b):
#     list(s)
#     for i in range(0, len(s)):
#         if s[i] == a:
#             s[i] = b
#     return s
#
# Объявить функцию  exclude(), которая получает два списка и удаляет из первого списка все элементы,
# которые встречаются во втором списке.
# [a,b,c,d], [b,d,e,f] => [a,c].
#
# def exclude(lst1, lst2):
#     for i in lst2:
#         if i  in lst1:
#             lst1.remove(i)
#     return lst1
#
# Объявить функцию myzip(), которая получает два списка равной длины и возвращает список пар.
# Каждая пара является двухэлементным списком, первый элемент пары берется из первого списка,
# второй – из второго. [1,2,3], ['a', 'b', 'c'] => [[1,'a'], [2,'b'], [3,'c']].
#
# def myzip(list0, list1):
#     res = []
#     for i in range(len(list0)):
#         res.append([list0[i], list1[i]])
#     return res

# Задан числовой список. Оставить в нем только положительные числа. Для этого объявить функцию positive(lst), которая ничего не возвращает, но изменяет список lst.
#
# def positive(lst):
#     for item in list(lst):
#         if item <= 0:
#             lst.remove(item)
#
# Задан числовой список. Переставить в нем числа так, чтобы вначале шли все отрицательные числа, а за ними все положительные.
# Для этого объявите функцию order, которая изменяет исходный список и нового списка не создает.
#
# def order(l):
#     l.sort()
#
# Дан двухуровневый список списков из целых чисел.
# Сделать из него новый одноуровневый список, в котором числа следуют в том же порядке.
# Например, [[1,2,3],[4,5],[1,2]]->[1,2,3,4,5,1,2].
# Определите функцию flatten(lst), которая получает двухуровневый список
# и возвращает одноуровневый.
#
# def flatten(lst):
#     res = []
#     for i in lst:
#         for j in i:
#             res.append(j)
#     return res
#
# Задан список, упорядоченный по возрастанию.
# Вставить в него новый элемент так, чтобы порядок не нарушился.
# Для этого объявите функцию ordInsert(lst,e), которая изменяет исходный список
# и нового списка не создает. Не использовать метод sort.
#
# def ordInsert(lst, e):
#     for index in range(0, len(lst)):
#         if e < lst[index] and e > lst[index - 1]:
#             lst.insert(index, e)
#             break
#         elif e < lst[0]:
#             lst.insert(0, e)
#             break
#         elif e > lst[len(lst) - 1]:
#             lst.append(e)
#             break
#
# Задан список из числовых списков. Отсортировать его по возрастанию сумм чисел во вложенных списках.
# Для этого объявите функцию sortBySum(lst), которая сортирует исходный список.
#
# def sortBySum(lst):
#     lst.sort(key=sum)
#
# Задан список. Оставить в нем только уникальные элементы, например, [1,3,2,4,3,2,1] => [1,3,2,4].
# Для этого объявите функцию distinct, которая получает исходный список
# и возвращает новый список, в котором нет повторяющихся элементов.
#
# def distinct(list1):
#     newlist = []
#     for x in list1:
#         if x not in newlist:
#             newlist.append(x)
#     return newlist

# Задача "Оставить положительные"
# Задан числовой список lst. Оставить в нем только положительные числа.
#
# lst = [x for x in lst if x >= 0]
#
# Создать двумерный список размером nхn и заполнить его единицами и нулями в шахматном порядке. В клетке [0, 0] должен быть 0.
# Для этого определите функцию chessboard(n), которая вернет требуемый список.
#
# def chessboard(n):
#     return [[(i+j)%2 for i in range(n)]for j in range(n)]
#
# Объявить функцию invert(), которая получает список и возвращает новый список,
# в котором элементы исходного списка следуют в обратном порядке.
# Не использовать метод reverse.
#
# def invert(my_list):
#     newList = []
#     for item in my_list[::-1]:
#         newList.append(item)
#     return newList
#
# Объявить функцию unzip(lst), которая получает список lst и копирует его в два новых списка,
# составленных из элементов, стоящих на четных и нечетных позициях исходного списка.
# Функция возвращает двухэлементный список, составленный из двух новых списков.
#
# def unzip(lst):
#     lst1 = lst[0::2]
#     lst2 = lst[1::2]
#     return[lst1, lst2]
#
# Определить функцию avg вычисления среднего с переменным числом параметров (от 2 до бесконечности).
#
# def avg(*numbers):
#     return (sum(numbers)) // len(numbers)

# Задача "Число и и индекс"
# Сосчитать, сколько раз в числовом списке совпадает число и его индекс.
#
# xs = [0, 5, 2, 1, 4]
# count = 0
# for i,x in enumerate(xs):
#     if i == x:
#         count += 1
#
# Объявить функцию summa(v1, v2), которая получает два двумерных вектора и возвращает их сумму.
# Вектор - это двуместный кортеж.
# Сложение векторов - это покомпонентное сложение кортежей.
#
# def summa(v1, v2):
#     return tuple((x+ y for y, x in zip(v1, v2)))
#
# Два отрезка на одной прямой задаются кортежами (a1, a2) и (b1, b2),
# причем a1 < a2, b1 < b2.
# Объявить функцию intersect(a, b), которая получает два отрезка (т.е. два кортежа)
# и возвращает третий отрезок (т.е. кортеж) – общую часть двух заданных.
# Если заданные отрезки не имеют общей части, функция дложна вернуть None.
#
# def intersect(p, q):
#     l=max(p[0], q[0])
#     r=min(p[1], q[1])
#     return (l,r) if l<=r else None
#
# Дана матрица (список списков). Присоединить к ней еще один столбец (просто список).
# Например, если ms = [[11, 12], [21,22]],  xs = [13, 23],  то новое значение ms = [[11, 12, 13], [21,22, 23]].
# Объявите функцию app(ms, xs), которая присоединяет столбец xs к матрице ms.
#
# def app(ms, xs):
#     for index, item in enumerate(xs):
#         ms[index].append(item)
#
# Задача "Ввод чисел"
# Ввести с клавиатуры числа, записанные в одну строку через пробел, например, 10 20 30 40 15 18. Числа сохранить в массиве.
#
# ss = input().split()
# ns = [int(s) for s in ss]
#
# Задано предложение, в котором слова разделены одним пробелом.
# Расположить слова в обратном порядке.
# Для этого определите функцию backward, которая получает строку с предложением и возвращает его в измененном виде.
#
# def backward(s):
#     lst = s.split()
#     return ' '.join(lst[::-1])
#
# Объявить функцию word(n), которая получает одноразрядное число (0 <= n < 10) и возвращает его прописью на русском языке.
# def word(n):
#     list1 = {1 : 'один', 2 : 'два', 3 : 'три', 4 : 'четыре', 5 : 'пять', 6 : 'шесть', 7 : 'семь', 8 : 'восемь', 9 : 'девять', 10 : 'десять'}
#     if (n < 10):
#         return list1.get(n)
#
# Задан текст, в котором слова разделены одним или более пробелами. Найти самое длинное слово.
# Для этого объявить функцию longest(t), которая возвращает самое длинное слово из текста t.
# Не использовать sort и sorted.
#
# def longest(t):
#     return (max(t.split()))
#
# Дана строка s. Заменить первое вхождение в нее подстроки a на подстроку b.
# Определить функцию myReplace(), которая получает строки s, a, b и возвращает результат замены в строке s первого вхождения подстроки a на подстроку b. Не использовать метод  replace().
# Учесть случай, когда подстроки a в строке s нет - тогда функция должна вернуть исходную строку s.
#
# def myReplace(s, a, b):
#     s_split=s.split(a,maxsplit=1)
#     return b.join(s_split)
#
# Даны два слова. Определить, можно ли составить второе слово из букв первого.
# Например, из букв слова "касатка" можно составить слово "такса", а слово "касса" составить нельзя.
# Объявите функцию puzzle(), которая получает два слова и возвращает логическое значение.
#
# def puzzle(old, new):
#     for letter in old:
#         new = new.replace(letter, '', 1)
#     if new:
#         return False
#     else:
#         return True
#
# Даны два слова. Выяснить, является ли одно из них анаграммой другого. Для этого объявите функцию anagram(), которая получает два слова и возвращает логическое значение.
#
# def anagram(w1, w2):
#     if sorted(w1) == sorted(w2):
#         return True
#     else:
#         return False
#
# Объявить функцию word(n), которая получает двузначное число (0 < n < 100) и возвращает его прописью на русском языке.
#
# def word(n):
#     f = {1: 'один', 2: 'два', 3: 'три', 4: 'четыре', 5: 'пять',
#          6: 'шесть', 7: 'семь', 8: 'восемь', 9: 'девять'}
#     o = {10: 'десять', 20: 'двадцать', 30: 'тридцать', 40: 'сорок',
#          50: 'пятьдесят', 60: 'шестьдесят', 70: 'семьдесят',
#          80: 'восемьдесят', 90: 'девяносто'}
#     s = {11: 'одиннадцать', 12: 'двенадцать', 13: 'тринадцать',
#          14: 'четырнадцать', 15: 'пятнадцать', 16: 'шестнадцать',
#          17: 'семнадцать', 18: 'восемнадцать', 19: 'девятнадцать'}
#     n1 = n % 10
#     n2 = n - n1
#     if n < 10:
#         return f.get(n)
#     elif 10 < n < 20:
#         return s.get(n)
#     elif n >= 10 and n in o:
#         return o.get(n)
#     else:
#         return o.get(n2) + ' ' + f.get(n1)